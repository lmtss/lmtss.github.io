投影网格，用来渲染无限大的地形，比如海面  
根据摄像头、网格的顶点uv和高度计算出世界空间的位置，再加上一个offset(通常是一个displayment-map)  
## bug
在一定距离上表现出网格位置的异常，尤其在移动摄像头时更为明显  
这样的artifact是在通常的网格中不会出现的
### 推测
通常的网格不出现这种问题是因为，通常的网格在远处的网格密度更大，有足够的网格来表现，但投影网格并非如此，会在远处缺少足够的顶点数量  
按照这种推测，不去使用一个均匀的2D网格来做，而是用一个越远越密的网格来做比较好  
或者，中间密、近处普通、远处疏？但是远处疏的话，在视角向下移动的时候会出问题，因为这时的'远处'不比近处远多少，也就是说同样需要较密的顶点。  
## 无限远
在摄像机看向远处时，根据算法，可能远处有部分网格是没在被使用的，比如‘海平面上方’的顶点，会因身处无限远而被折叠。  
一个思路是在cpu根据摄像机得出一个uv的缩放值(应该只是影响uv.y)  
## 性能优化
投影网格的顶点数据只需要uv就可以了，或许uv也可以通过ID来推断？  
如果能够完全省去顶点数据，那么既可以节省内存，也可以降低带宽，取而代之的是alu  
同时indexbuffer类似的技术仍是需要的，可以尝试用三角形条带  
三角形条带的优化效果可能不及indexbuffer。比如，使用条带渲染方方正正的gird，一行行的绘制，那么不同的两行仍有重复的顶点  
这样来想，indexbuffer方式大概优化为`1/6`，而三角形条带约为`1/3`  

## 动态网格密度
如果完全按照ID推算，那么可以实现动态的网格密度
## index
一个问题是基于索引的绘制，保存在framedata内的结构，是否也会受到indexbuffer影响  
# Profile
google pixel 2  
使用三角形条带 & 没有任何顶点缓冲  
和  
默认的使用Mesh渲染  
前者会略快一点点，如果加上了采样displacement，可能会逆转  
所以还是需要indexbuffer   
采样了displacement纹理之后，发现耗时测试上不稳定，难以确定优化的程度，不过比起采样纹理的耗时，减少的顶点缓冲的耗时相对较少，感觉用处不大