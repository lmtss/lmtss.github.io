翻译[GiGa体素](https://maverick.inria.fr/Membres/Cyril.Crassin/thesis/CCrassinThesis_EN_Web.pdf)  
# 5 数据结构
## 5.1 基于八叉树的体素mipmap pyramid：一个稀疏的多分辨率结构
对于渲染大场景来说，一个自适应空间划分是必要的，考虑到内存限制也是如此。
### 5.1.1 八叉树+块
这是一种复合结构，将层次结构和均匀(regular)结构的优点结合。层次结构是八叉树，非空/非常数节点是小的体素体积。这些小的体素体积是低分辨率的均匀网格，称为`块`(`bricks`)。块(bricks)是预定义大小$M^3$的网格，网格的内容是对子树的近似。例如，根节点的块是对整个树的近似。这种方案对应2.4.4描述的层次分块方案  
在第六节我们探讨3D纹理加速渲染  
这样的结构结合了两个优点  
* 八叉树带来的紧凑储存(compact storage)(空内容skip，遮挡剔除，局部细化)；同时块由3D纹理实现，因此受益于硬件加速的插值和缓存一致性。
* 另一个优点是节点和块的大小恒定。 因此，将它们密集地存储在 GPU 的内存池中很简单（第 5.2.1 节）。 这有助于更新机制，这对于确保生成输出图像所需的数据的存在至关重要（第 7 章）。  
   
### 5.1.4 块
为了确保块在边缘处硬件三线性插值的正确，一些体素必须和相邻块重复。不重复的插值以前被提出过，不过带来更大的消耗。
### 5.2.2 八叉树节点编码
每个节点由一个数据项和一个子节点（子）指针组成。 数据项可以是一个常量值（对于空的/均匀的体积），也可以是指向砖块的指针(X-Y-Z-10-10-10)。 如前所述，节点池中的每个实体对应于 $N^3$ 个（通常为 8 个）子节点。 正是这个属性允许我们只依赖一个子指针。 由于所有子节点都连续存储在内存中，因此可以通过向指针添加常量偏移量来寻址任何单个子节点。(就是说子节点在内存中的地址是有规则限制的，所以不需要记录8个地址)  
我们的结构产生了一个非常紧凑的八叉树编码，因为每个节点仅由两个 32 位整数值表示。 第一个整数用于定义八叉树结构，第二个用于关联体数据。  
* 第一个整数中，
  * 第一位表示节点是否为终结点(terminal)，true意味着是否是细化程度最大的(叶子节点？)，false意味着还包含更多数据，需要对节点进行细分。
  * 第二位用于指示第二个整数值的性质，它表示恒定颜色还是指向 30 位编码的砖块的指针。 
  * 剩下 30 位用于指向子节点的子指针。
### 指针的表示和其拓展性
* `节点指针`：记载着池中`节点瓦片`(node tiles)的序号。每个节点瓦片由$N^3$个节点组成，每个节点是8字节(指两个32bit吧)。
* `块指针`： 块存储在一个位于3D纹理的池中。