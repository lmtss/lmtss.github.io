翻译[GiGa体素](https://maverick.inria.fr/Membres/Cyril.Crassin/thesis/CCrassinThesis_EN_Web.pdf)  
# 5 数据结构
## 5.1 基于八叉树的体素mipmap pyramid：一个稀疏的多分辨率结构
对于渲染大场景来说，一个自适应空间划分是必要的，考虑到内存限制也是如此。
### 5.1.1 八叉树+块
这是一种复合结构，将层次结构和均匀(regular)结构的优点结合。层次结构是八叉树，非空/非常数节点是小的体素体积。这些小的体素体积是低分辨率的均匀网格，称为`块`(`bricks`)。块(bricks)是预定义大小$M^3$的网格，网格的内容是对子树的近似。例如，根节点的块是对整个树的近似。这种方案对应2.4.4描述的层次分块方案  
在第六节我们探讨3D纹理加速渲染  
这样的结构结合了两个优点  
* 八叉树带来的压缩储存(compact storage)(空内容skip，遮挡剔除，局部细化)；同时块由3D纹理实现，因此受益于硬件加速的插值和缓存一致性。
* 另一个优点是节点和块的大小恒定。 因此，将它们密集地存储在 GPU 的内存池中很简单（第 5.2.1 节）。 这有助于更新机制，这对于确保生成输出图像所需的数据的存在至关重要（第 7 章）。  
   
### 5.1.4 块
为了确保块在边缘处硬件三线性插值的正确，一些体素必须和相邻块重复。不重复的插值以前被提出过，不过带来更大的消耗。
### 5.2.2 八叉树节点编码
每个节点由一个数据项和一个子节点（子）指针组成。 数据项可以是一个常量值（对于空的/均匀的体积），也可以是指向砖块的指针(X-Y-Z-10-10-10)。 如前所述，节点池中的每个实体对应于 $N^3$ 个（通常为 8 个）子节点。 正是这个属性允许我们只依赖一个子指针。 由于所有子节点都连续存储在内存中，因此可以通过向指针添加常量偏移量来寻址任何单个子节点。