翻译学习论文[Collision-Streams Fast GPU-based Collision Detection for Deformable Models]()  
这篇文章的思路：  
1 尽量将所有计算都拆成流式，
2 基于BVH
3 利用上一step的数据，利用可变形物体的时间相干性，也就是文中的front stream、BVTT。具体介绍在另一个论文中。
4 孤儿集 Orphan set
5 
6 流注册 用来进行流压缩
## 摘要
我们提出了一个快速的基于GPU的流式算法来实现可变性物体间的碰撞查询。我们的方法是基于层次剔除并减少产生不同流的计算量。我们提出了一个新奇的`流注册方式来压缩流`并高效地计算潜在的图元碰撞对。我们还使用`延迟的前端跟踪方法(deferred front tracking)来降低内存开销`。整个算法已经在不同的gpu上实现了，我们评估了对非刚体和可变性物体模拟的表现。实际上，我们的算法可以在数十毫秒内对由成千上万个三角形组成的模型执行对象间和对象内计算。
## 介绍
物理模拟、机器人动作等应用，都涉及到检测是否有两个以上物体的图元重叠问题。底层模拟器需要去检测物体间的碰撞和可变形物体内的自碰撞。该领域的最新工作是`连续碰撞检测(CCD)，它通过插值平滑运动来检查两个离散时间实例之间的碰撞`。除此之外，很多交互性应用能够用这个算法达到30-60Hz或更高。  
在基于边界体积层次结构（BVH）的碰撞检测快速算法设计方面，有大量工作要做。 最近的工作包括开发适当的剔除技术，这些技术会根据原语之间的成对相交测试减少误报的数量。 大多数较早的算法本质上都是串行的，并且是为单核或处理器设计的。 但是，计算机体系结构的最新趋势是开发并行商用处理器，包括多核CPU和多核GPU。 预计核的数量将以摩尔定律所对应的速率增加。考虑到这些趋势，已经针对商品并行处理器提出了许多并行冲突检测算法。 在本文中，我们主要处理设计基于GPU的快速算法，该算法可以利用数据和线程级并行性，并且在使用各种剔除技术方面具有灵活性。
`我们的贡献`：我们提出了一种新颖的基于GPU的冲突检测算法，该算法将GPU抽象为流处理器，擅长与内核并行处理流数据。我们的方式`基于BVH`，并将计算减少到生成各种流。我们还提出了一种新颖的流注册方法，以有效支持可变长度数据结构，该结构可以由多个线程并行更新。这为我们提供了灵活性，使其可以`并入许多剔除方法`，这些方法基于孤儿集(`Orphan sets`)[Tang等.2009]，代表性三角形(`Representative triangles`)[Curtis等.2008]和非渗透过滤器(`non-penetration filters`)[Tang等.2010a]，这可以提高基于GPU的算法的整体性能。我们还使用了延迟的前端跟踪方案，该方案可以减少内存开销，并可以在GPU上处理大型复杂模型。总体算法(碰撞流)可以很好地映射到当前的GPU架构，我们评估其在NVIDIA GeForce GTX GPU和AMD Radeon HD 5870 GPU上的性能。  
这个碰撞检测算法无需对物体或运动做任何假设，可以以物体空间精度检测所有物体之间和物体内部的碰撞，并最大程度地减少相邻三角形之间的基本测试次数。我们还分析了作为核心数量或流处理器数量的函数的算法性能。实际上，碰撞流可以在数十毫秒内在由数十万个三角形组成的复杂可变形模型之间执行CCD计算。我们着重介绍了相对于以前的基于CPU和基于GPU的算法的加速以及较低的内存开销。 此外，结合其他剔除技术相对容易。  
`文章结构`：剩下的部分如此组织：第二节是前人工作的总结。第三节中我们提出了我们的流算法，结合流注册和延迟前端追踪。第四节中，我们提出了细节实现以及表现力重点。第五节中我们与过去的算法做了比较。  
## 2 相关的工作
### 2.1 流压缩
流压缩通常在GPU上使用，以去除稀疏数据表示形式中不需要的元素。在我们的流CCD算法中，使用了几个包含稀疏数据的流(例如可能碰撞的三角形对或可能碰撞的特征对)，并且需要对其进行压缩以实现良好的性能。使用的实际流数据元素远小于O(N^2)个可能的对(N是场景中总三角形的数量)，因此，所得数据结构需要支持稀疏数据表示。  
许多快速流压实[Horn.2005;哈里斯等.2007年;Billeter等.2009年]和扫描算法已为当前的GPU设计[Sengupta等.2011;Merrill和Grimshaw.2009年]。为了使用这些方法生成碰撞流，生成的算法将需要O(N^2)空间复杂度，这会将它们的应用限制在相对简单的模型中。
## 3 流式连续碰撞检测
在本节中，我们将介绍符号并介绍基于碰撞流的CCD算法。 我们假定场景由多个可变形对象组成。 我们的算法会为整个场景建立一个BVH，并执行自上而下的遍历以检查对象之间和对象内部的碰撞。 我们`不对运动或变形进行任何假设`，并且假设我们在每个时间帧都获得了网格所有顶点的位置。 在CCD计算方面，该算法假定顶点之间进行线性插值运动，并且通过在特征(即顶点、边和面)之间进行基本测试来计算首次接触时间。
### 3.1 算法总览
我们的算法基于BVH，从广义上讲包括以下阶段：  
1.每一帧，更新三角形位置、包围盒并使用重适应(refitting)算法更新整个场景的BVH。  
2.遍历BVH并在包围盒(BV)之间执行成对测试，以计算可能相交的三角形的列表。可以通过保持所得BVTT（边界遍历树）的前端来加速此步骤[Tang等.2010b]，从而减少了成对BV测试的次数。  
3.对于所有可能碰撞的三角形对，在其特征（顶点，边和三角形）之间执行基本测试。 每对三角形之间的CCD测试减少到15个基本测试，其中包括6个VF（顶点面）和9个EE（边缘-边缘）测试。 基础测试的数量可以基于“孤儿集”而减少[Tang等。 2009]和代表性三角形[Curtis等。 2008]。 每个基本测试都简化为求解三次方程，可以通过使用非渗透滤波器来加速它[唐等人。 2010a]。  

为了利用GPU的计算能力，我们将层次遍历和交叉测试映射到碰撞流，可以利用当前GPU上的并行性。
### 3.2 碰撞流
为了充分利用当前GPU强大的并行计算能力，我们将它们建模为可以对流数据执行大规模细粒度并行计算的流处理器的集合。就整个CCD算法而言，几何数据表示为流数据，算法中使用的基础功能模块(即更新BVH，BV之间的成对测试，基本测试等)映射到计算内核。  
对应于几何数据的流数据包括：  
`顶点流` \\(S_v\\): 这些对应于可变形对象的顶点的几何坐标。 为了在两个离散时间步长之间执行连续碰撞检测，两个顶点流\\(S_v(t_0)\\)和\\(S_v(t_1)\\)用于存储分别对应于时间t0和t1的顶点坐标。  
`包围盒流` \\(S_{bv}\\) 和 `BVH流` \\(S_{bvh}\\): BV流表示三角形、边、顶点的包围盒。整个场景由一个BVH(\\(S_{bvh}\\))包围。这两个流在每一个step基于\\(S_v\\)更新。  
`front流` \\(S_f\\): 这些是与BVTT前端相对应的节点，即在上一个时间步中树遍历终止的内部节点和叶节点。  
`三角形对流` \\(S_t\\): 在BVH遍历期间，将边界体积重叠的所有不相邻的三角形对收集到St中。在执行基本测试之前，这些潜在碰撞的三角形对以不同的特征表示，包括顶点，边缘和面。 我们使用有代表性的三角形[Curtis等。 2008]，以确保不会复制多个三角形共享的特征。 这减少了存储开销和基本测试的数量。  
`特征对流` \\(S_g\\) 和 `孤儿流` \\(S_o\\): 所有具有重叠边界体积的不相邻三角形对都将分解为最多9个EE和6个VF特征对。这些特征对通过使用与特征相关联的BV进行进一步剔除，并使非穿透性滤镜变形[Tang等.2010a]。满足这些测试的所有对都成为特征对流Sg的一部分。此外，通过对Sg执行流压缩，可以删除所有无效特征对以及剔除的特征对。与网格中相邻三角形相关的所有特征对均表示为孤立流So的一部分。因此，通过分析与每个对象相对应的网格的拓扑结构和连通性，在预处理阶段构造了So。  
`Intersection 流` \\(S_i\\):   
算法1中显示了我们算法的流水线。所有过程都映射到一组计算内核(如图3所示)。 通过执行这些内核，流CCD算法完全在GPU上运行。  
### 3.3 更新front流
为了并行执行碰撞检测任务，我们的算法使用了基于BVTT前沿并行更新的任务分解策略，即通过利用可变形模拟的连续时间步之间的时间相干性。  
来自先前模拟时间步长的BVTT前沿表示为前沿流Sf（t0）。它由内核“更新BVTT前端”评估，该内核在当前模拟时间步长更新BVTT前端，即计算新的前端流Sf（t1）。我们使用临时堆栈存储中间结果，同时在BVTT前节点{Da，Db}上进行递归横向执行。具有重叠边界体积的节点对存储为Sf（t1）。如果Da和Db均为叶节点，则此对将存储在三角形对流St中，因为它对应于潜在的碰撞对。临时堆栈是通过使用GPU上的寄存器存储器实现的。