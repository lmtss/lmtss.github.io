翻译学习论文 [MCCD: Multi-Core Collision Detection between Deformable Models using Front-Based Decomposition]()  
这篇文章主要讲如何利用之前step的信息来计算碰撞检测。作者写的另一篇文章引用了这一篇。谷歌翻译很好用。  
这个论文里面的front这个单词就很微妙，看了好久没明白什么意思。

## 摘要
我们提出了一种新颖的并行算法，用于使用多核处理器的可变形模型之间的快速连续碰撞检测(CCD)。 我们使用分层表示来加速这些查询，并提出一种利用连续帧之间的时间一致性的增量算法。 我们的公式通过使用基于过去信息(front)的细粒度分解将计算分布在多个内核之间。我们还提出了有效的技术，以减少基本测试的数量并分析我们方法的可扩展性。 我们已经在8核和16核PC上实现了并行算法，并在复杂基准测试中分别观察到高达7倍和13倍的加速。  
## 介绍
快速连续碰撞检测(CCD)是基于物理的仿真，虚拟环境和机器人运动计划中出现的重要问题。CCD可以通过计算插值运动来检查对象离散位置之间的碰撞，并减少碰撞检查的问题，从而找到非线性多项式方程的根[1]。实际上，`CCD还用于计算离散实例之间的首次接触时间`。  
在本文中，我们主要处理非刚性模型之间的快速CCD计算，其中场景可能包含破碎的物体或经受变形运动的物体。很多文献中已经研究了这个问题，并且已经有了许多高效的算法。但是，当前的方法无法在复杂的基准上提供交互式性能(即数十毫秒或更短)。  
本文的目标之一是利用当前的体系结构趋势来实现更快的碰撞查询。最近和将来的商用处理器变得越来越平行。从广义上讲，有两种商用处理器：包括性能最佳的串行内核的多核CPU和旨在实现更高并行代码性能的目标的多核处理器（例如GPU）。这些处理器具有不同的特性，在本文中，我们将自己限于使用多核CPU来加速CCD查询。这与最近使用GPU进行更快的碰撞检测的工作是正交的。  
略  
开发有效的并行冲突检测算法的主要挑战之一是在多个内核之间平均地平衡负载并获得高内存和高速缓存吞吐量。大多数现有的碰撞检测算法使用BVH来加速计算。在可变形模型的情况下，基于模型图元的相对配置，层次结构的遍历成本可能会有很大变化。 这可能导致变化的负载和不规则的访问方式。 挑战之一是设计并行层次结构遍历算法，该算法可以在所有不同的配置上很好地工作，并且可以随核的数量很好地扩展。  
我们的并行方法基于可变形模型之间最新的CCD研究[2，3]。 具体来说，我们提出了一种新颖的并行CCD算法，可以很好地映射到当前的多核CPU体系结构。 我们的算法执行增量计算，利用连续帧之间的相干性，还检查可变形模型之间的自碰撞（图1）。 我们使用BVTT（边界遍历树）的概念并保持BVTT前沿(front)。 该前端(front)以增量方式更新，用于将整体计算分解为多个内核之间的子任务。 我们还提出了有效的并行技术，以自适应地更新前端并减少基元之间的基本测试数量。  
`主要贡献`：  
1 我们拓展了先前的基于front的针对刚体的增量算法，将其拓展到包括自碰撞检测的可变形物体。我们使用2-3树代替传统的二叉树来表示BVTT，我们展示了我们的算法能够显著地减少遍历的花费。  
2 我们提出了适应性的策略来计算BVTT的front，通过提出新的指标(metrics)，并且基于孤儿集减少图元之间的基本测试(elementary test)。  
3 我们提出了一个基于front的解构(FBD)的高度可变长的平行CCD算法，该算法在16核工作站上有着相关于核心数的线性的速度提升。算法尽力将不同线程间同步的开销化为最小，并且使用缓存友好的结构来改进表现。  
4 我们分析了FBD算法的复杂度核可扩大性，并且与过去的平行算法相比较。  

并行CCD算法已经在具有4K-92K三角形的许多复杂基准上进行了测试，这些三角形分别对应于可变形模拟，破碎对象和N体模拟。 与优化的串行实现相比[3]，我们在8核工作站上获得6.4X-7.7X的加速，而在16核工作站上获得10.1X-13X的加速。 实际上，我们的算法可以在这些基准上以每帧5.3ms-32.5ms的速度检查所有冲突，包括自冲突。 据我们所知，这是在商品系统上运行的最快的并行碰撞检测算法。   

`文章结构`：  
2章 先前工作 - CCD和平行碰撞检测   
3章 介绍概念符号，处理各种问题  
4章 整个平行CCD算法  
5章 分析表现  
6章 实现细节  
7章 比较  

## related work
### 2.1 可变形物体的BVH
### 2.2 CCD
### 增量碰撞检测
许多研究人员已经利用空间和时间相干性来在交互式应用程序中更快地检测碰撞。 主要思想是在连续帧之间执行增量碰撞计算。 这些包括用于凸多面体[21，22]和凸壳[23]的增量方法。 一些层次算法在层次结构中维护一个前端，并使用该前端进行更快的遍历[12、24、23、25]。 这些技术大多数已用于加速刚性模型之间的碰撞检查。 针对可变形模型，提出了基于事件的算法[26]和动力学分离列表[27]。
### 平行碰撞检测和模拟
## 3
### 3.1
使用模型的边界体积层次结构可以加速几何模型之间的碰撞检测。 我们的方法还基于计算和更新边界体积层次结构。 遍历之后，我们在基元之间执行重叠测试。 在本文的其余部分中，我们假设图元是三角形，然后执行连续测试，即它们之间的基本测试，以基于三角形顶点之间的线性插值运动来检查碰撞。 在本文的其余部分中，我们使用以下术语  
`BVHs:` 层次包围盒（BVH）用于加速碰撞和接近性查询。 我们使用单个BVH表示包含可变形模型的场景。 我们从BVH的根节点开始遍历层次结构，检查自身冲突和对象间冲突。 我们的遍历算法独立于基础包围盒。  
`BVTT:` 包围盒测试树（BVTT）表示遍历期间执行的重叠测试的层次结构。 BVTT是一种表示，主要用于碰撞检测算法的设计和分析[45，23，33，27]。 我们扩展了先前的公式来处理自碰撞和可变形模型。 BVTT中的每个节点表示一对边界体积（BV）之间的单个重叠测试，或一个BV上的自碰撞测试。 结果，BVTT不再是二叉树，并且我们的BVTT的某些内部节点可能具有三个子节点。  
`BVTT front:` BVTT的front是一组中间节点和叶节点，遍历BVH终止时，当前所遍历到的节点就是front。 front反映了碰撞查询的每个实例遍历了多少棵树。  
### 3.2 CCD计算
关于在刚性，铰接式和可变形模型之间进行CCD计算的快速算法，已有大量文献。 但是，由于以下原因，当前算法无法在复杂模型上实现交互性能（即每秒20帧或更多）：[19、20、3]：  
略  
我们的目标是通过设计一种新的CCD算法来改善性，该算法能可以很好地映射到当前的多核处理器。 设计良好的并行算法的关键是均衡内核之间的负载。 我们的方法基于[3]中描述的串行分层算法。 该算法包括四个阶段：  
更新BVH：涉及重新计算要素的边界体积，并更新BV，以使它们按层次包围基础模型。  
BVTT遍历和对计算：以深度优先的方式遍历BVTT，执行边界体积测试，并收集可能碰撞的非相邻三角形对。  
测试非相邻三角形对：对通过边界体积测试的非相邻三角形对执行基本测试。  
测试相邻三角形对：使用孤立集公式[3]在相邻对之间进行必要的基础测试。  
### 3.3 平行层次计算
如表1所示，通过使用孤立集，在相邻对上花费的运行时间可以忽略不计。 所有基准的比率均低于0.4％。  
就其他三个阶段而言，BVH更新和不相邻对处理相对容易在多个内核上并行化。 另一方面，BVTT遍历和对计算的并行化相对困难。 结果，`并行冲突检测的主要挑战是提出用于BVTT遍历和计算潜在重叠对的适当并行技术`。  
用于CCD计算的最简单并行算法是基于将常规并行化方法扩展到此问题的[41、42、43、44]。 最终的方法是PHC，它代表并行分层计算。  
在算法的第二阶段，即[3]中的BVTT遍历和对计算阶段，PHC需要首先以广度优先的顺序遍历BVTT，收集所有冲突查询子任务并将其放在堆栈中。 然后，在多个处理器或内核上并行执行堆栈中的所有子任务。 PHC的运行示例如图3所示。  
然而这种方法(PHC)由一个对应于广度优先遍历BVTT的串行部分和收集子任务组成。实际上，这种简单的方法存在两个主要瓶颈：  
碰撞查询的评估：由于变形模型的动态特性，很难估计或评估两个BVH节点之间的碰撞查询的计算量。 较差的估计将导致负载不平衡，并且冲突查询的成本可能会根据基元的相对配置而发生很大变化。  
可扩展性：为实现良好的并行化，PHC需要分配足够的子任务以使所有内核保持繁忙。 `在这种情况下，广度优先遍历就成为一个复杂度相关于核数的串行开销。`  
我们已经实现了基于PHC的并行CCD算法，并在16个核心工作站上观察到基准速度提高了3.7X -5.1X（图4）。 此外，这种方法不能很好地扩展内核数量。 结果，我们需要一种改进的基于层次的算法来更快地进行并行碰撞检测。  
## 4 基于FBD的平行CCD
在本节中，我们介绍了一种使用基于front的分解（FBD）的新颖并行CCD算法。它基于可变形模型的新颖的基于前端的算法，并使用front在多个内核之间执行改进的任务分解。  
### 4.1
为了设计一种可以很好地随内核数量扩展的并行算法，需要考虑当前多核CPU的几个特性：  
同步开销：在多核处理器上，线程同步可能会非常昂贵，尤其是对于交互式应用程序而言。 因此，我们的目标是设计一种同步开销较低的算法。  
细粒度任务分解：用于多核CPU的冲突检测算法设计中的关键问题是设计适当的细粒度任务分解方案。 底层任务分解应基于图元的相对配置进行调整，并能够平衡不同内核之间的负载。  
缓存友好的内存布局：现代多核处理器上的内核通常共享一些片上缓存。 由于多个线程尝试访问相同的内存位置，因此可能导致速度变慢。 我们使用BVH和BVTT前端的缓存友好的内存布局来提高缓存利用率，从而提高运行时性能。  
鉴于这些限制，我们针对可变形模型设计了三阶段并行碰撞检测算法。 这三个阶段如图5所示。为了消除同步瓶颈，原始串行算法中的两个阶段，即BVTT遍历和非相邻对处理，合并为一个阶段，称为BVTT前端跟踪。 在此阶段，我们使用FBD执行细粒度的任务分解并实现良好的可伸缩性。  
### 4.2
### 4.3 基于front的拆解
通过将BVTT用于可变形模型，我们可以以统一的方式处理对象间和对象内的碰撞。 如图6所示，我们利用前跟踪通过利用时间相干性以有效的方式执行冲突查询。 具体来说，我们跟踪连续帧之间的front，并使用增量计算对其进行更新。  
随着对象在仿真过程中变形或移动，BVTT前端需要相应地更新。为了维持有效的战线，使用了两个操作员“发芽”和“修剪” [24、23、25]。这两个算子分别对应于BVTT前沿的扩展和收缩。通过使用发芽运算符，可以将发芽的前端发芽到不合并边界卷或达到树中的叶节点的水平。修剪其父级不相交的两个同级BVTT节点会递归生成更紧凑的前端，并减少计算量。  
每个前节点的萌芽彼此独立。这使其适用于并行处理。修剪运算符需要在BVTT前端搜索同级节点，很难并行执行。   
实际上，我们不使用任何修剪运算符，因为它会影响并行性能。相反，我们使用发芽算子逐步跟踪BVTT前沿，并使用自适应重建策略来计算更紧凑的BVTT前沿。  
在跟踪BVTT前端期间，将需要发芽的节点标记为无效，并且将以深度优先的方式遍历其后代以检查冲突。遍历终止的节点将插入当前的BVTT前端。  
由于仿真中的时间连贯性，更新每个节点的计算量大约是平衡的。因此，FBD是一种很好的细粒度任务分解方法。它克服了PHC的缺点，并可以提供潜在的可扩展性能。  
### 4.4 