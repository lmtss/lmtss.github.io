显而易见的，本篇用来翻译学习[Unified Particle Physics for Real-Time Applications](https://dl.acm.org/doi/10.1145/2601097.2601152)这篇文章。不会都翻译。同时我发现谷歌翻译比我懂中文，所以很多都是谷歌翻译。  
## 遇到的词汇
stiff 刚性  
penalty force model 惩罚力模型  
configurations 构造  
least squares best transform 最小二乘变换  
sequential quadratic programming  SQP序列二次规划  
拉格朗日乘子  
Gauss's principle of least constraint  高斯最小约束
## 3 Particle Representation
我们选择粒子作为所有物体类型的基本构建单位。粒子简单且容易实现，同时足够灵活来表示我们想要模拟的物体。通过使用粒子构建所有的物体，我们减少了需要处理的碰撞类型的数量，不需要复杂的算法来产生基于网格表示的物体间的联系（contact）。粒子的粒度适合平行化。为了发挥GPU的优势，我们选择那些考虑平行处理大量简单粒子交互的算法，而非顺序运行的先进算法。  
我们的核心粒子状态包含如下的属性：  
```cpp
struct Particle{
    float x[3];
    float v[3];
    float invmass;
    int phase;
}
```
我们用一个粒子phase标识符拓展了一般的动力学量。这个整数值用来将粒子组织成组，提供一个简单的方式来调整他们的属性，控制他们的交互，比如，禁用同组内粒子之间的碰撞。我们做了一个限制，将每个场景的粒子半径设为固定，以便利用基于均匀网格的有效碰撞检测。
## 4 平行SOR解算器
## 4.1 背景
我们构建了一个使用派生于PBD的通用约束解算器的系统。PBD系统包括非线性等式和不等式约束，  
$$
C_i(\vec x + \Delta \vec x) = 0,\ i = 1,...,n\ (1)
$$
$$
C_j(\vec x + \Delta \vec x) \ge 0,\ j = 1,...,n\ (2)
$$
公式中有 \\(\vec x = [\vec {x_1},\vec {x_2},...,\vec {x_n}]^T\\) ,x代表粒子的位置向量。约束的经典解算方式是使用GS迭代法，并且将\\(C\\)在\\(x\\)处展开，
$$
C_i(\vec x + \Delta \vec x) \approx C_i(\vec x) + \nabla C_i(\vec x)\Delta \vec x = 0.\ \ (3)
$$
位置变化量\\(\Delta \vec x\\)，被限制在沿着约束梯度的方向，使用质量导数矩阵 \\(M = diag(m_1,..,m_n)\\)加权，
$$
\Delta x = M^{-1}\nabla C_i(\vec x)^T\lambda _i\ \ (4)
$$
结合公式(3)和(4)，\\(\lambda _i\\)的公式为
$$
\lambda _i = -\frac{C_i(\vec x)}{\nabla C_i(\vec x)M^{-1}\nabla C_i(\vec x)^T}\ \ (5)
$$
一般来说，在处理每一个约束后，更新位置，经过大量的迭代，按照总约束变化量来改变速度
$$
\Delta \vec v = \frac{\Delta \vec x}{\Delta t}\ \ (6)
$$
## 4.2 优化观点
这里，我们提出了另一个观点，将PBD视为一个有条件优化(constrained optimization)的问题。仅考虑等式约束，问题可以被描述为公式(7)：
$$
求最小\ \ \frac{1}{2}\Delta \vec x^TM\Delta \vec x
$$
$$
符合\ C_i(\vec x + \Delta \vec x) = 0,\ \ i = 1,...,n
$$
变量\\(\Delta x\\)是满足约束的位置变化量。按照公式(6)，。因此，问题等同于找到满足约束条件的动能的最小变化，这与高斯的最小约束原理是一致的。  
如果约束函数是线性的，公式(7)就是一个二次规划问题。实践中，约束往往是非线性、非凸函数，对此，没有快速、全局优化的解算器。PBD使用SQP通过线性化约束并计算一序列QP问题来解决：
$$
求最小\ \ \frac{1}{2}\Delta \vec x^TM\Delta \vec x
$$
$$
符合\ J\Delta x = b
$$
这里，\\(J = \nabla C(x)\\)，\\(b = [-C_1,...,-C_n]^T\\)。这类问题(在线性约束下求二次目标函数最小值)能被转化为以下优化情况。
$$
M\Delta x = J^T\lambda\ \ (9)
$$
$$
J\Delta x = b\ \ (10)
$$
第一个式子来自拉格朗日乘数法，公式左边是目标函数的梯度，第二个式子来自
## 4.3 SOR
如上面描写的平均约束力确保了收敛，但是在一些情况，这种平均十分过激并且求解所需的迭代次数增加。我们提出一个控制SOR率的全局用户参数w来解决这个问题。

## 5 刚体
Harada[[2007]()]和Bell[[2005]()]使用惩罚力模型的粒子表示去模拟刚体，同时Tonge[[2010]()]使用粒子去侦测联系来构建一个基于约束力的GPU刚体解算器。另一个方式是通过距离约束来联系晶格粒子来构建刚体，然而这种方式需要很多迭代来表现刚性。  
我们用粒子表示非凸刚体，使用刚体形状匹配约束[[Muller et al. 2005]()]来保持粒子构造。通过首先对封闭的三角形网格进行体素化并将粒子放置在该形状内部的已占据单元格中，来创建形状。然后，我们为形状中的所有粒子分配相同的相位(phase)标识符，禁用它们之间的碰撞，并向系统添加形状匹配约束。
在进行模拟的时候，我们处理粒子就像他们没有联系，使他们被其他类型的约束处理。
## 5.1用稀疏符号距离场解决碰撞
Harada[[2007]()]使用属于刚体的粒子间的离散元素的力来解决碰撞。然而，物体可能会互锁并无法分开。我们用一种基于稀疏符号距离场(SDF)的新的粒子碰撞算法。  
Guendelman et al. [[2003]()]使用符号距离场来产生非凸刚体之间的联系。然后使用顺序的迭代方案解决冲突，其中，每个特征都按照最深的穿透顺序从形状中投影出来。与它，使用基于刚体的SDF方法，相比，我们为属于一个刚体的每一个粒子采样一个场函数。通过将SDF存储于粒子，我们能重新使用我们粒子-粒子碰撞侦测的机制来解决形状间更深的重叠。我们存储每个粒子位置的SDF值和梯度（图7）。