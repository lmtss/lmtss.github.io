显而易见的，本篇用来翻译学习[Unified Particle Physics for Real-Time Applications](https://dl.acm.org/doi/10.1145/2601097.2601152)这篇文章。不会都翻译。同时我发现谷歌翻译比我懂中文，所以很多都是谷歌翻译。  
## 遇到的词汇
stiff 刚性  
penalty force model 惩罚力模型  
configurations 构造  
least squares best transform 最小二乘变换  
sequential quadratic programming  SQP序列二次规划  
拉格朗日乘子  
## 3 Particle Representation
我们选择粒子作为所有物体类型的基本构建单位。粒子简单且容易实现，同时足够灵活来表示我们想要模拟的物体。通过使用粒子构建所有的物体，我们减少了需要处理的碰撞类型的数量，不需要复杂的算法来产生基于网格表示的物体间的联系（contact）。粒子的粒度适合平行化。为了发挥GPU的优势，我们选择那些考虑平行处理大量简单粒子交互的算法，而非顺序运行的先进算法。  
我们的核心粒子状态包含如下的属性：  
```cpp
struct Particle{
    float x[3];
    float v[3];
    float invmass;
    int phase;
}
```
我们用一个粒子phase标识符拓展了一般的动力学量。这个整数值用来将粒子组织成组，提供一个简单的方式来调整他们的属性，控制他们的交互，比如，禁用同组内粒子之间的碰撞。我们做了一个限制，将每个场景的粒子半径设为固定，以便利用基于均匀网格的有效碰撞检测。
## 4 平行SOR解算器
## 4.1 背景
我们构建了一个使用派生于PBD的通用约束解算器的系统。  
$$
C_i(x + \Delta x) = 0,\ i = 1,...,n\ (1)
$$
$$
C_j(x + \Delta x) \ge 0,\ j = 1,...,n\ (2)
$$
## 4.3 SOR
如上面描写的平均约束力确保了收敛，但是在一些情况，这种平均十分过激并且求解所需的迭代次数增加。我们提出一个控制SOR率的全局用户参数w来解决这个问题。

## 5 刚体
Harada[[2007]()]和Bell[[2005]()]使用惩罚力模型的粒子表示去模拟刚体，同时Tonge[[2010]()]使用粒子去侦测联系来构建一个基于约束力的GPU刚体解算器。另一个方式是通过距离约束来联系晶格粒子来构建刚体，然而这种方式需要很多迭代来表现刚性。  
我们用粒子表示非凸刚体，使用刚体形状匹配约束[[Muller et al. 2005]()]来保持粒子构造。通过首先对封闭的三角形网格进行体素化并将粒子放置在该形状内部的已占据单元格中，来创建形状。然后，我们为形状中的所有粒子分配相同的相位(phase)标识符，禁用它们之间的碰撞，并向系统添加形状匹配约束。
在进行模拟的时候，我们处理粒子就像他们没有联系，使他们被其他类型的约束处理。
## 5.1用稀疏符号距离场解决碰撞
Harada[[2007]()]使用属于刚体的粒子间的离散元素的力来解决碰撞。然而，物体可能会互锁并无法分开。我们用一种基于稀疏符号距离场(SDF)的新的粒子碰撞算法。  
Guendelman et al. [[2003]()]使用符号距离场来产生非凸刚体之间的联系。然后使用顺序的迭代方案解决冲突，其中，每个特征都按照最深的穿透顺序从形状中投影出来。与它，使用基于刚体的SDF方法，相比，我们为属于一个刚体的每一个粒子采样一个场函数。通过将SDF存储于粒子，我们能重新使用我们粒子-粒子碰撞侦测的机制来解决形状间更深的重叠。我们存储每个粒子位置的SDF值和梯度（图7）。