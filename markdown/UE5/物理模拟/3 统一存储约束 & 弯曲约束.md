这次要修改以前写的PBD布料      
[物理模拟笔记-0-一个超简单PBD](https://zhuanlan.zhihu.com/p/449897373)   

在之前的实现中，布料网格结构是写死在代码逻辑中，现在我要重构代码，来支持使用StaticMesh生成布料的约束   

# 数据

## Mesh数据
当前我使用顶点色来标注哪些顶点时固定点，使用UE自带的paint工具就能刷顶点色，还算方便，不过理想上物理数据应该和渲染数据分开。   



## 距离约束的Buffer
```cpp
// 距离约束的Buffer
// 粒子A的ID
FRWBuffer DistanceConstraintsParticleAIDBuffer;
// 粒子B的ID
FRWBuffer DistanceConstraintsParticleBIDBuffer;
// 距离Buffer
FRWBuffer DistanceConstraintsDistanceBuffer;
```

# GPU上生成距离约束
这里我用一般的方式，将网格中三角形的一个边视为一个距离约束，也就是使用边上的两个顶点(粒子)和边的长度构建距离约束。边的信息可以从indexbuffer中获取，indexbuffer此处可以是为一个长为 $3N$的数组，$N$指三角形数量，存储顶点的id，每3个顶点构成一个三角形。   

<div align=center><img src="../../../img/physics/Triangle-Distance-Constraints.png"><div>每个边生成一个距离约束</div></div>   

不过此处的一个问题在于，很多时候两个三角形会共享一个边，如果不加处理，会生成重复的距离约束。   

<div align=center><img src="../../../img/physics/Triangle-Distance-Constraints-2.png"><div>共享边</div></div>   

我这里的解决方式是实现一个去重算法，来将有重复key的buffer压缩为无重复key的buffer。算法借鉴了一下[tensorflow的实现](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/unique_op_gpu.cu.h)。   

去重算法的大概流程  
* [3, 5, 3, 4, 1, 4, 9, 8, 6, 3, 5, 7, 8, 8, 4, 6, 4, 2, 5, 6] -- 0
* 排序，得到排序后的buffer，  
  [1, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 8, 9] -- 1  
* 对buffer-1 判断一个位置是否是连续相同数据(segment)的边界，其实就是判断左边的数据和自己是否相同   
  [1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1] -- 2
* 对buffer-2 进行归约操作就能得到每个标为1的值的输出位置，进而将buffer压缩成unique的

这里的排序，我是使用UE中的GPU基数排序   
[UE引擎中的GPUSort 基数排序](https://zhuanlan.zhihu.com/p/452636510)   

大概代码就是
```cpp
// 依据indexbuffer，每一个边生成一个key
GenerateDistanceConstraintsKeyFromMesh(...);    

// 对key进行排序，这里不需要value
int32 BufferIndex = SortGPUBuffers(
    RHICmdList
    , GPUSortBuffers
    , 0
    , 0xFFFFFFFF
    , NumTriangles * 3
    , ERHIFeatureLevel::SM5
);

// 对排序后的key进行去重(求前缀和)
CompactSortedKey(...);

// 根据key来得到原本的边的信息，来构造距离约束
GenerateDistanceConstraintsByCompactKey(...);
```
GPU上求前缀和的算法网上很多，我也写过一篇     
[UE引擎中的归约算法](https://zhuanlan.zhihu.com/p/452965458)
# 弯曲约束
我这里的弯曲约束的生成和距离约束的生成算法很像，都是基于两个三角形共享一条边这个前提来做。区别在于生成弯曲约束的时候，不仅仅是对key进行排序，而是key-value对，value中记录这三角形的id。这样，就能在去重之后得知两个有共享边的三角形的id，进而知道弯曲约束的四个点。   

下面用边的key的buffer距离，value的buffer也就是三角形id略去
* [3, 5, 4, 1, 9, 8, 6, 3, 7, 8, 4, 2, 5, 6] -- 0
* 排序，得到排序后的buffer，  
  [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8, 8, 9] -- 1  
* 对buffer-1 判断左边的数据是否和自己相同，相同为 1 (和距离约束不同)   
  [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0] -- 2
* 对buffer-2 进行归约操作，同时将key对应的value输出


# 刚性

# 约束投影
此处的一个问题在于，我是将约束数据存成了buffer，相对独立于粒子，在计算矫正值的时候，是每个线程对应一个约束。也就是说，可能有多个gpu线程影响一个粒子的位置。   
一般情况下，会使用原子操作来处理这种情况，但是我使用的是计算着色器，并不支持浮点数的原子操作。   

此处参考了战神4的做法，将浮点数乘以(1<<16)，转为一个有符号整形，来进行原子操作  
<div align=center><img src="../../../img/physics/GodOfWar-Atomic-Add.png"><div>GDC - Wind Simulation in 'God of War'</div></div>   




# 动态顶点法线
为了能够正常渲染布料或是计算风力、碰撞，我们需要计算出顶点的法线。   
思路是计算出每一个面的法线，然后累积到每个顶点上，最后每个顶点对这个累积量归一化。   
计算面法线的原理十分简单，获取两个边的向量进行叉乘，就能得到一个垂直于面的向量。  
```cpp
float3 Normal = normalize(cross(Position1 - Position2, Position0 - Position2));
```  

# 动态顶点切线
之前虽然编写了动态计算法线的代码，但是却没有计算切线，这意味着无法使用法线贴图，所以接下来添加一个动态计算切线的功能计算切线的原理参考 [Computing Tangent Space Basis Vectors for an Arbitrary Mesh](http://www.terathon.com/code/tangent.html)。   
要计算法线，我们需要的是三角形的顶点的位置 (和计算法线一样)以及顶点的 UV，UV可以从StaticMesh的RenderData中获取。  

```cpp
FStaticMeshLODResources& StaticMeshResourceLOD0 = RenderData->LODResources[0];
FStaticMeshSectionArray& StaticMeshSectionArray = StaticMeshResourceLOD0.Sections;
FRawStaticIndexBuffer& MeshIndexBuffer = StaticMeshResourceLOD0.IndexBuffer;
FStaticMeshVertexBuffers& MeshVertexBuffers = StaticMeshResourceLOD0.VertexBuffers;

TexCoordBufferSRV = MeshVertexBuffers.StaticMeshVertexBuffer.GetTexCoordsSRV();
```  

<div align=center><img src="../../../img/NormalTangent/TexCoord-Format.png"><div>UE中UV的Buffer，格式是R16G16F</div></div>    

首先用下面的公式计算出面的切线和副切线，并累积到顶点
$$
\vec{Q_1}=\vec{P_1}-\vec{P_0}\\
\vec{Q_2}=\vec{P_2}-\vec{P_0}\\
(s_1,t_1)=(u_1-u_0,v_1-v_0)\\
(s_2,t_2)=(u_2-u_0,v_2-v_0)\\
\begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix} = \frac{1}{s_1t_2-s_2t_1}\begin{bmatrix} t_2 & -t_1 \\ -s_2 & s_1 \end{bmatrix} \begin{bmatrix} (\vec{Q_1})_x & (\vec{Q_1})_y & (\vec{Q_1})_z \\ (\vec{Q_2})_x & (\vec{Q_2})_y & (\vec{Q_2})_z \end{bmatrix}
$$
得到累积后的切线和副切线后，用下面的公式计算顶点的切线   
$$
\vec{T^{\prime}}=normalize(\vec{T}-(\vec{N}\cdot\vec{T})\vec{N})
$$  
副切线是没有必要存入顶点数据的，因为可以通过法线和切线的叉乘计算出来，只需要存储一个bool来表示方向，比如存储在rgba8中的alpha通道里面。   
这个值可以这样计算   
```cpp
(dot(cross(Normal, Tangent), Bitangent) < 0.0) ? 0.0 : 1.0
```   

# VertexFactory
为了让顶点着色器能够从buffer中获得计算出来的法线和切线，我们需要在VertexFactory中编写代码，来计算出一个切线空间转到世界空间的矩阵。  
比如说，材质蓝图中的`VertexNormalWS`节点，对应的代码是`Parameters.TangentToWorld[2]`，此处的`TangentToWorld`就是我们要计算出的矩阵。   

在`LocalVertexFactory`中，这个矩阵是先计算出一个`TangentToLocal`矩阵，在将其转换为`TangentToWorld`，不过我之前的计算都是发生在世界空间，所以直接计算`TangentToWorld`就行。    

```cpp
struct FVertexFactoryIntermediates
{
	float3 Position;
	float4 TexCoords;
	half3x3 TangentToWorld;
	half TangentToWorldSign;
};
```

```cpp
half3x3 CalcTangentToWorld(half3 WorldNormal, half4 TangentWithW, inout half TangentSign)
{
	half3 TangentX = TangentBias(TangentWithW.xyz);
	half3 TangentZ = TangentBias(WorldNormal);

	TangentSign = TangentZ.w;

	half3 TangentY = cross(TangentZ.xyz, TangentX) * TangentZ.w;
	
	half3x3 Result;
	Result[0] = cross(TangentY, TangentZ.xyz) * TangentZ.w;
	Result[1] = TangentY;
	Result[2] = TangentZ.xyz;

	return Result;
}
```

```cpp
half3 Normal = NormalBuffer[Input.VertexId].xyz * 2.0 - 1.0;
half4 TangentWithW = TangentBUffer[Input.VertexId] * 2.0 - 1.0;

half TangentSign;
Intermediates.TangentToWorld = CalcTangentToWorld(Normal, TangentWithW, TangentSign);
Intermediates.TangentToWorldSign = TangentSign;

```

然后在`GetMaterialVertexParameters`函数中赋值
```cpp
FMaterialVertexParameters GetMaterialVertexParameters(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, half3x3 TangentToLocal)
{
    ...

	Result.TangentToWorld = Intermediates.TangentToWorld;

    ...

}
```
到这里，材质蓝图中顶点的部分就能取到顶点法线、切线的值，接下来要让PixelShader也能取到，进而可以将法线贴图的法线转到世界空间。  
首先要设置好`VS-PS`过程中插值的数据，在这里指的就是TBN矩阵   
```cpp
FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, FMaterialVertexParameters VertexParameters)
{
    ...
	SetTangents(Interpolants, Intermediates.TangentToWorld[0], Intermediates.TangentToWorld[2], Intermediates.TangentToWorldSign);

    ...

}
```
接下来要将插值的数据(`FVertexFactoryInterpolantsVSToPS`)转为`FMaterialPixelParameters`
```cpp
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants, float4 SvPosition)
{
    ...

	half3 TangentToWorld0 = GetTangentToWorld0(Interpolants).xyz;
	half4 TangentToWorld2 = GetTangentToWorld2(Interpolants);
	Result.UnMirrored = TangentToWorld2.w;

	Result.TangentToWorld = AssembleTangentToWorld( TangentToWorld0, TangentToWorld2 );

	...

	return Result;
}
```  
这样PixelShader就能通过`Parameters.TangentToWorld`获得TBN矩阵了。比如说，在材质蓝图中，如果将法线贴图连到`Normal`输出当中，那么编译时就会用`TangentToWorld`将其转为世界空间。   


# UE组件
上面讲的基本都是物理模拟相关的，下面讲一下其他部分的实现   

我个人是希望在插件中实现这些功能，所以我不会去修改引擎的代码。因此我创建了一个新的Component，继承`UMeshComponent`并实现自己的`SceneProxy`和`VertexFactory`，这样我可以在渲染时，读取动态计算出来的buffer来获取位置、法线等数据。    


# VertexFactory
我之前将vf存储在sceneproxy上，但实际上vf应该是和mesh对应的，当材质变更的时候，vf不应该随之重新创建。比如static mesh component的sceneproxy就是引用的staticmesh的`FStaticMeshRenderData`数据，从而获得里面的vf    

# 风力
可以通过`FScene::GetDirectionalWindParameters`获取