再前几章，模拟基本都放在了一个ComputeShader中，这一章将他拆分  
对于约束，拆分成`产生约束`和`约束投影`两个部分，这两个部分通过`约束数据流`来沟通。这样做的一个好处是，不同物体的同种约束可以放在一个`流`中，一起被计算，就像延迟渲染   
像是布料中的距离约束，在布料没被破坏的情况下，不改变对应的约束数据，而动态产生的约束，比如碰撞，则是不断产生  
# 粒子
全部以粒子描述，每个粒子有自己的唯一ID，这个ID在整个场景中是唯一的。  
# 约束数据流
每一种约束放在不同的buffer中处理  
一个查找表，存储每一个粒子对应约束数据的起始位置，用下一个粒子的起始位置减去当前的起始位置就能得到约束的数量
## 距离约束
粒子a和b的约束，存为两份，一份对应a的，一份对应b  
对于粒子 a，存储`距离`、`刚性`、`粒子b的ID`
## 碰撞约束
# 约束投影
此阶段的每个线程独自处理单一的粒子，且任一线程都不处理其他线程的粒子，这样能够保证在写入时不会有同步问题。  